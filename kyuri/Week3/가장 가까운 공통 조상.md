## 문제 : [백준 3584 가장 가까운 공통 조상](https://www.acmicpc.net/problem/3584)
### 구현 방법 및 회고

**1. **문제 요약****
</br>
루트가 있는 트리에서 두 노드의 가장 가까운 공통 조상을 구하는 것이다.
</br>
(두 노드를 모두 자손으로 가지면서 가장 가까운 노드)
</br>
</br>
**2. **구현 방법****
</br>
BFS 이용해서 구현
</br>
</br>
입력을 받고, 저장을 할 때 자식 인덱스 위치에 부모를 저장함 (자식 기준)
</br>
</br>
공통 조상을 구할 두 노드 각각 BFS를 진행함
</br>
tree에 부모가 저장되어 있으므로 입력받은 노드부터 거슬러 올라 
</br>
탐색을 하게 되면 list의 끝은 항상 루트로 끝나게 됨
</br>
</br>
구한 각 리스트를 끝에서부터 같은지 확인하고, 같다면 ans를 갱신함
</br>
</br>
[EX]
</br>
문제 예시 사진 기준 15와 10의 공통 조상을 찾는다면,
</br>
깊이 우선 탐색을 진행해 반환된 리스트는 아래와 같다.
</br>
15 : [15, 6, 4, 8]
</br>
10 : [10, 4, 8]
</br>
</br>
**3. **회고****
</br>
tree에 정보들을 저장할 때 자식은 무조건 부모가 한 개인데, 여러 개 있을 수 있다고 착각해서
</br>
ArrayList를 2차원으로 만들었으나, 그냥 1차원 배열로 했어도 됐었다.
</br>
분명히 로직은 정확한데 계속해서 틀렸다고 나와서 이해가 되지 않았다.
</br>
구한 각 list에서 같은 조상을 찾기 위해 문자열이 아닌 정수는 ==을 사용해도 된다고 생각한 것이 문제였다.
</br>
반환한 list의 타입이 Integer이었기 때문에 참조형이므로 ==을 사용하면 주소를 비교하게 된다는 것을 모르고 있었다.
</br>
Integer에서 값을 비교하려면 .equals() 함수를 이용해 비교해야 한다는 것을 알게 되었다.
</br>
정확하게 이해하고 있는 것의 중요성을 깨달았다...
