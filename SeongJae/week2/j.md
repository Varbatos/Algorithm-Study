구현방법


bfs를 bfs(int 다음 이동할 곳,int 시간):으로 전달하면서 목적지를 찾고
목적지를 찾았을때 걸렸던 시간을 저장하고 큐에 있던 같은 시간을 전부 다 탐색하면 된다.

<사진으로 설명하겠다>
![캡처](https://github.com/user-attachments/assets/70427ea5-26b6-4ccb-84e4-29fad5ab3ea0)


<17을 찾을때 시점에서 queue 시점 >

deque([(17, 4),(32, 4), (13, 4), (15, 4), (28, 4), (22, 4), (26, 4), (23, 4), (25, 4), (48, 4), (17, 4), (19, 4), (36, 4), (21, 4), (23, 4), (44, 4), (38, 4), (42, 4), (39, 4), (41, 4), (80, 4), (0, 5), (15, 5), (28, 5), (17, 5), (36, 5), (30, 5)])


(32,4)~(80,4)까지 찾는게 중요하다.

<코드 부분>

if (0 <= des && des <= 100000 && !visited[des] && (!isFindResult || time < deadline)) {
// 범위안에 들어 와야하고 and 방문한적 없어야 하고 and( 목적지를 못찾았거나 or 찾았으면 deadline까지 잘 지켰는가?)
                    queue.add(new int[]{des, time + 1});
                }



회고

무난한 bfs활용 문제
중복 탐색에 대해 관대해서 숨바꼭질 1에서 코드 3줄 추가해서 풀었지만 시간이 빡빡했으면 시간마다 큐를 따로 저장해서 방문체크를 한 다음 큐를 집어 넣는방식으로 구현해야하는데 
시간 커트라인이 조금만 줄였다면 난이도가 더 어려웠을꺼 같다.

