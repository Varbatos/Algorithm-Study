# LinkedList vs ArrayList [백준 3190 뱀]
# ArrayList (배열을 이용)

## 문제점

- 배열 공간이 꽉 차거나, 요소 중간에 삽입을 행하려 할때 기존의 배열을 복사해서 요소를 뒤로 한칸씩 일일히 이동해야하는 작업이 필요하다.
- 이러한 부가적인 연산은 시스템의 성능 저하로 이어져 삽입/삭제가 빈번하게 발생하는 프로세스의 경우 치명적일 수 있다.
- 지속적으로 삭제되는 경우, 그 공간 만큼 낭비되는 메모리가 많아지게 되고 또한 리사이징 처리에서 시간 소모된다.

![](https://velog.velcdn.com/images/hyobin0726/post/928b7829-fafb-4cb8-aea3-344e580d6f97/image.png)

# LinkedList (노드를 연결)

## 장단점

### 장점

- 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있기 때문에 공간의 제약이 존재하지 않는다.
- 삽입 역시 노드가 가리키는 포인터만 바꿔주면 되기 때문에 삽입/삭제 처리 속도가 빠르다.

### 단점

- 요소를 get하는 과정에서 arraylist는 무작위 접근이 가능하지만, **linkedlist는 순차접근**만 가능하다.

![](https://velog.velcdn.com/images/hyobin0726/post/1a0cce75-5c82-426a-82bd-190c092cc38a/image.png)

- arraylist는 하나의 연속적인 묶음으로 자료를 저장하는 반면, linkedlist는 자료들을 저장 공간에 불연속적인 단위로 저장하게 된다.
- 메모리 이곳저곳 산재해 저장되어 있는 노드들을 접근하는데 있어 긴 시간이 소모된다.

⇒ 소량의 데이터를 가지고 사용할 때는 사실 큰 차이가 없지만,정적인 데이터를 활용하면서 조회가 빈번하다면 ArrayList를 사용하는 것이 좋고,동적으로 추가/삭제 요구사항이 빈번하다면 LinkedList를 사용하는 것이 좋다.

### 그래서 Stack, Queue는 ArrayList, LinkedList와 어떤 상관이 있지?

위에서 Queue를 기차에 비유해서 설명할 때, LinkedList와 유사하다는 생각이 들었을 것이다.

결론적으로 **Queue**는 **FIFO** 용도로 사용하기 때문에 Queue를 구현할 때, **LinkedList로 구현**한다.

- 노드를 동적으로 추가 및 삭제가 가능하기 때문에, 첫 번째 데이터의 삽입 및 삭제 작업이 효율적이다.

반대로 **Stack을** 구현할 때는 **LIFO** 원칙에 따라 **ArrayList**로 구현한다.

- 마지막 요소에 빠르게 접근하여 삽입 및 삭제를 수행할 수 있다.이는 ArrayList가 내부적으로 배열을 사용하여 인덱스 기반 액세스가 빠르기 때문이다.

### 문제 : 백준 3190 뱀
[3190 뱀](https://www.acmicpc.net/problem/3190)
### 구현방법 및 회고

보드는 2차원 배열이며, 사과가 놓인 위치를 1로 표기하였다.

이동 방향의 경우, 기본 오른쪽으로 이동하다가 D라면 시계방향으로 L이라면 반시계방향이 된다. 

뱀의 방향 변환 시간과 방향 정보를 key, value 쌍으로 데이터를 관리하는 집합인 hashmap에 추가하였다. key값에 시간을 넣어 해당 시간일때 방향 변환을 하였다.

뱀의 이동 정보를 LinkedList로 삽입/삭제를 하였다.

사과를 만났을때 마지막에 값을 추가하고, snake의 노드 가장 앞부분은 삭제하고 가장 뒷부분은 방향에 맞게 +1하여 추가하였다. 

종료 조건은 보드를 벗어나거나 자기 자신의 몸과 부딪히면 끝난다. 보드를 벗어나는건 그래프관련 문제와 같이 구현하였지만, 자기 자신의 몸과 부딪히는 건 구현하기 어려웠다.

뱀의 이동정보를 담는 snake에 이동할 좌표인 nx,ny가 있다면 종료하도록 하였다.

2차원 배열의 구현과 자료구조를 활용한 문제였다. 구현 방법까진 생각했으나, 구체적인 코드 작성이 어려워 결국 답을 봤다.

